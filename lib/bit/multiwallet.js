// Generated by CoffeeScript 1.8.0
(function() {
  var ECKey, HDNode, MultiWallet, bitcoin, bs58, crypto, randomBytes, txUtils;

  bitcoin = require("bitcoinjs-lib");

  HDNode = bitcoin.HDNode, ECKey = bitcoin.ECKey;

  crypto = require('crypto');

  randomBytes = require('randombytes');

  bs58 = require('bs58');

  txUtils = require('./transaction_utils');

  module.exports = MultiWallet = (function() {
    var NETWORKMAP, getNode;

    NETWORKMAP = {
      testnet3: 'testnet',
      testnet: 'testnet',
      bitcoin_testnet: 'testnet',
      bitcoin: 'bitcoin',
      mainnet: 'bitcoin'
    };

    getNode = function(arg) {
      if (arg instanceof HDNode) {
        return arg;
      } else if (typeof arg === 'string') {
        return HDNode.fromBase58(arg);
      } else {
        throw Error("Unusable type " + (typeof arg));
      }
    };

    MultiWallet.generate = function(names, networkName) {
      var masters, name, network, networkDetails, node, seed, _i, _len;
      if (networkName == null) {
        networkName = 'testnet';
      }
      if (!(networkName in NETWORKMAP)) {
        throw Error("Unknown network " + networkName);
      }
      network = NETWORKMAP[networkName];
      masters = {};
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        seed = randomBytes(32);
        networkDetails = bitcoin.networks[network];
        node = HDNode.fromSeedBuffer(seed, networkDetails);
        node.seed = seed;
        masters[name] = node;
      }
      return new this({
        "private": masters,
        network: network
      });
    };

    function MultiWallet(options) {
      var arg, name, privateTrees, _ref;
      this.privateTrees = {};
      this.publicTrees = {};
      this.trees = {};
      if ('network' in options && options.network in NETWORKMAP) {
        this.network = NETWORKMAP[options.network];
      } else {
        this.network = NETWORKMAP['testnet'];
      }
      privateTrees = options["private"];
      if (privateTrees == null) {
        throw Error("Must supply private");
      }
      for (name in privateTrees) {
        arg = privateTrees[name];
        this.privateTrees[name] = this.trees[name] = getNode(arg);
      }
      if ('public' in options) {
        _ref = options["public"];
        for (name in _ref) {
          arg = _ref[name];
          this.publicTrees[name] = this.trees[name] = getNode(arg);
        }
      }
    }

    MultiWallet.prototype.prepareTransaction = function(transactionContent, txb) {
      var encodedSignatures, inputs, outputs, paths, signatures;
      txb = txb || new bitcoin.TransactionBuilder();
      inputs = transactionContent.inputs, outputs = transactionContent.outputs;
      this.addInputs(inputs, txb);
      this.addOutputs(outputs, txb);
      paths = txUtils.getPathsForInputs(inputs);
      signatures = this.signAllInputs(paths, txb);
      encodedSignatures = this.encodeSignatures(signatures);
      return {
        signatures: encodedSignatures,
        txHash: txb.tx.getHash().toString('hex')
      };
    };

    MultiWallet.prototype.addInputs = function(inputs, transactionBuilder) {
      return inputs.forEach(function(input) {
        var ASM, index, prevOutScript, prevTx;
        prevTx = input.output.transaction_hash;
        index = input.output.index;
        ASM = input.output.script.string;
        prevOutScript = bitcoin.Script.fromASM(ASM);
        return transactionBuilder.addInput(prevTx, index, void 0, prevOutScript);
      });
    };

    MultiWallet.prototype.addOutputs = function(outputs, transactionBuilder) {
      return outputs.forEach(function(output) {
        var ASM, scriptPubKey, value;
        ASM = output.script.string;
        scriptPubKey = bitcoin.Script.fromASM(ASM);
        value = output.value;
        return transactionBuilder.addOutput(scriptPubKey, value);
      });
    };

    MultiWallet.prototype.getPubKeysForPath = function(path) {
      var masterNodes, pubKeys, trees;
      trees = trees;
      masterNodes = ['backup', 'cosigner', 'primary'].map((function(_this) {
        return function(nodeName) {
          var masterNode;
          masterNode = _this.trees[nodeName];
          return _this.deriveNodeForPath(masterNode, path);
        };
      })(this));
      return pubKeys = masterNodes.map(function(node) {
        return node.pubKey;
      });
    };

    MultiWallet.prototype.getPrivKeyForPath = function(path) {
      var primaryChildNode, primaryMasterNode, privKey;
      primaryMasterNode = this.privateTrees.primary;
      primaryChildNode = this.deriveNodeForPath(primaryMasterNode, path);
      return privKey = primaryChildNode.privKey;
    };

    MultiWallet.prototype.createRedeemScript = function(pubKeys, numberOfSigs) {
      if (numberOfSigs == null) {
        numberOfSigs = 2;
      }
      return bitcoin.scripts.multisigOutput(numberOfSigs, pubKeys);
    };

    MultiWallet.prototype.deriveNodeForPath = function(parent, path) {
      var node;
      node = parent;
      path.forEach(function(index) {
        return node = node.derive(index);
      });
      return node;
    };

    MultiWallet.prototype.signAllInputs = function(paths, txb) {
      var inputs, signatures;
      signatures = [];
      inputs = txb.tx.ins;
      inputs.forEach((function(_this) {
        return function(input, index) {
          var path, privKey, pubKeys, redeemScript, signature;
          path = paths[index];
          pubKeys = _this.getPubKeysForPath(path);
          privKey = _this.getPrivKeyForPath(path);
          redeemScript = _this.createRedeemScript(pubKeys);
          txb.sign(index, privKey, redeemScript);
          signature = txb.signatures[index].signatures[0];
          return signatures.push(signature);
        };
      })(this));
      return signatures;
    };

    MultiWallet.prototype.encodeSignature = function(signature, hashType) {
      if (hashType == null) {
        hashType = 1;
      }
      return bs58.encode(signature.toScriptSignature(hashType));
    };

    MultiWallet.prototype.encodeSignatures = function(signatures) {
      var encodedSignatures;
      return encodedSignatures = signatures.map((function(_this) {
        return function(signature) {
          return _this.encodeSignature(signature);
        };
      })(this));
    };

    return MultiWallet;

  })();

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  var PassphraseBoxAES, crypto;

  crypto = require("crypto");

  module.exports = PassphraseBoxAES = (function() {
    var ITERATIONS, ITERATIONS_RANGE;

    ITERATIONS = 90000;

    ITERATIONS_RANGE = 20000;

    PassphraseBoxAES.encrypt = function(passphrase, plaintext, callback) {
      return new this({
        passphrase: passphrase
      }, function(error, box) {
        return callback(error, box.encrypt(plaintext));
      });
    };

    PassphraseBoxAES.decrypt = function(passphrase, encrypted, callback) {
      var ciphertext, iterations, iv, salt;
      salt = encrypted.salt, iterations = encrypted.iterations, iv = encrypted.iv, ciphertext = encrypted.ciphertext;
      return new this({
        passphrase: passphrase,
        salt: salt,
        iterations: iterations
      }, function(error, box) {
        return callback(error, box.decrypt(ciphertext, iv));
      });
    };

    function PassphraseBoxAES(_arg, callback) {
      var array, passphrase, salt;
      passphrase = _arg.passphrase, salt = _arg.salt, this.iterations = _arg.iterations;
      if (salt) {
        this.salt = new Buffer(salt, "hex");
      } else {
        try {
          this.salt = crypto.randomBytes(16);
        } catch (_error) {
          throw new Error("Error generating random bytes");
        }
      }
      if (!this.iterations) {
        array = [0];
        crypto.getRandomValues(array);
        this.iterations = ITERATIONS + (array[0] % ITERATIONS_RANGE);
      }
      crypto.pbkdf2(passphrase, this.salt, this.iterations, 64, (function(_this) {
        return function(error, buffer) {
          if (error) {
            return callback(error);
          }
          _this.aes_key = buffer.slice(0, 32);
          _this.hmac_key = buffer.slice(32, 64);
          return callback(null, _this);
        };
      })(this));
    }

    PassphraseBoxAES.prototype.encrypt = function(plaintext, iv) {
      var aes, ciphertext, encrypted, mac;
      try {
        if (iv == null) {
          iv = crypto.randomBytes(16);
        }
      } catch (_error) {
        throw new Error("Error generating random bytes");
      }
      aes = crypto.createCipheriv('aes-256-cbc', this.aes_key, iv);
      encrypted = aes.update(plaintext, 'utf8');
      encrypted = Buffer.concat([encrypted, aes.final()]);
      mac = crypto.createHmac('sha256', this.hmac_key).update(Buffer.concat([iv, encrypted])).digest();
      ciphertext = Buffer.concat([encrypted, mac]);
      return {
        iterations: this.iterations,
        salt: this.salt.toString("hex"),
        iv: iv.toString("hex"),
        ciphertext: ciphertext.toString("hex")
      };
    };

    PassphraseBoxAES.prototype.decrypt = function(cipherData, iv) {
      var aes, cipherDataBuf, ciphertext, decrypted, hmacNew, hmacOld, ivBuf;
      cipherDataBuf = new Buffer(cipherData, 'hex');
      ivBuf = new Buffer(iv, 'hex');
      ciphertext = cipherDataBuf.slice(0, -32);
      hmacOld = cipherDataBuf.slice(-32).toString('hex');
      hmacNew = crypto.createHmac('sha256', this.hmac_key).update(Buffer.concat([ivBuf, ciphertext])).digest().toString('hex');
      if (hmacOld !== hmacNew) {
        throw new Error('Invalid authentication code - this ciphertext may have been tampered with');
      }
      aes = crypto.createDecipheriv('aes-256-cbc', this.aes_key, Buf);
      decrypted = aes.update(ciphertext, 'hex', 'utf8');
      return decrypted += aes.final('utf8');
    };

    return PassphraseBoxAES;

  })();

}).call(this);

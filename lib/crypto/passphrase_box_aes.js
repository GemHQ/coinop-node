// Generated by CoffeeScript 1.8.0
(function() {
  var PassphraseBoxAES, crypto;

  crypto = require("crypto");

  module.exports = PassphraseBoxAES = (function() {
    var ITERATIONS;

    ITERATIONS = 100000;

    PassphraseBoxAES.encrypt = function(passphrase, plaintext, callback) {
      return new this({
        passphrase: passphrase
      }, function(error, box) {
        return callback(error, box.encrypt(plaintext));
      });
    };

    PassphraseBoxAES.decrypt = function(passphrase, encrypted, callback) {
      var ciphertext, iterations, nonce, salt;
      salt = encrypted.salt, iterations = encrypted.iterations, nonce = encrypted.nonce, ciphertext = encrypted.ciphertext;
      return new this({
        passphrase: passphrase,
        salt: salt,
        iterations: iterations
      }, function(error, box) {
        return callback(error, box.decrypt(ciphertext, nonce));
      });
    };

    function PassphraseBoxAES(_arg, callback) {
      var passphrase, salt;
      passphrase = _arg.passphrase, salt = _arg.salt, this.iterations = _arg.iterations;
      if (salt) {
        this.salt = new Buffer(salt, "hex");
      } else {
        try {
          this.salt = crypto.randomBytes(16);
        } catch (_error) {
          throw new Error("Error generating random bytes");
        }
      }
      if (this.iterations == null) {
        this.iterations = ITERATIONS;
      }
      crypto.pbkdf2(passphrase, this.salt, this.iterations, 64, (function(_this) {
        return function(error, buffer) {
          if (error) {
            return callback(error);
          }
          _this.aes_key = buffer.slice(0, 32);
          _this.hmac_key = buffer.slice(32, 64);
          return callback(null, _this);
        };
      })(this));
    }

    PassphraseBoxAES.prototype.encrypt = function(plaintext, nonce) {
      var aes, ciphertext, encrypted, mac;
      try {
        if (nonce == null) {
          nonce = crypto.randomBytes(16);
        }
      } catch (_error) {
        throw new Error("Error generating random bytes");
      }
      aes = crypto.createCipheriv('aes-256-cbc', this.aes_key, nonce);
      encrypted = aes.update(plaintext, 'utf8');
      encrypted = Buffer.concat([encrypted, aes.final()]);
      mac = crypto.createHmac('sha256', this.hmac_key).update(Buffer.concat([nonce, encrypted])).digest();
      ciphertext = Buffer.concat([encrypted, mac]);
      return {
        iterations: this.iterations,
        salt: this.salt.toString("hex"),
        nonce: nonce.toString("hex"),
        ciphertext: ciphertext.toString("hex")
      };
    };

    PassphraseBoxAES.prototype.decrypt = function(cipherData, nonce) {
      var aes, cipherDataBuf, ciphertext, decrypted, hmacNew, hmacOld, nonceBuf;
      cipherDataBuf = new Buffer(cipherData, 'hex');
      nonceBuf = new Buffer(nonce, 'hex');
      ciphertext = cipherDataBuf.slice(0, -32);
      hmacOld = cipherDataBuf.slice(-32).toString('hex');
      hmacNew = crypto.createHmac('sha256', this.hmac_key).update(Buffer.concat([nonceBuf, ciphertext])).digest().toString('hex');
      if (hmacOld !== hmacNew) {
        throw new Error('Invalid authentication code - this ciphertext may have been tampered with');
      }
      aes = crypto.createDecipheriv('aes-256-cbc', this.aes_key, nonceBuf);
      decrypted = aes.update(ciphertext, 'hex', 'utf8');
      return decrypted += aes.final('utf8');
    };

    return PassphraseBoxAES;

  })();

}).call(this);
